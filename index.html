<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Nova Arena · Rogue Survivor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --accent: #38bdf8;
      --accent-2: #22c55e;
      --accent-3: #f97316;
      --danger: #ef4444;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --panel: rgba(15, 23, 42, 0.92);
      --border: #1f2937;
      --radius-lg: 18px;
      --shadow-soft: 0 20px 50px rgba(0, 0, 0, 0.8);
      --transition-fast: 0.16s ease-out;
      --transition-med: 0.25s ease-out;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: radial-gradient(circle at top, #020617 0, #000 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* GAME ROOT FULLSCREEN */
    #game-root {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: radial-gradient(circle at top, #020617 0, #000 75%);
    }

    #game-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at center, #020617 0, #000 80%);
      image-rendering: pixelated;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      font-size: 14px;
      color: var(--text);
    }

    /* HUD */

    #hud-top {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      pointer-events: none;
      flex-wrap: wrap;
    }

    .hud-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .hud-pill {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      backdrop-filter: blur(12px);
      padding: 4px 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      pointer-events: auto;
    }

    .hud-label {
      color: var(--text-soft);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .hud-value {
      font-weight: 600;
    }

    #xp-bar-wrapper {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      width: min(70%, 680px);
      background: rgba(15, 23, 42, 0.95);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      overflow: hidden;
      pointer-events: auto;
    }

    #xp-bar-inner {
      position: relative;
      height: 14px;
      width: 100%;
      background: radial-gradient(circle at top, #020617 0, #020617 60%);
    }

    #xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      box-shadow: 0 0 16px rgba(34, 197, 94, 0.9);
      transition: width 0.15s linear;
    }

    #xp-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #e5e7eb;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.9);
      pointer-events: none;
    }

    #top-left-hints {
      position: absolute;
      left: 8px;
      top: 56px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
      pointer-events: none;
      font-size: 11px;
      color: var(--text-soft);
      text-align: left;
    }

    /* Overlays */

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .overlay-visible {
      pointer-events: auto;
    }

    .overlay-card {
      min-width: min(420px, 90%);
      max-width: 520px;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.08), rgba(15, 23, 42, 0.96));
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      box-shadow: var(--shadow-soft);
      padding: 16px 18px 14px;
      transform: translateY(14px) scale(0.97);
      opacity: 0;
      transition: opacity var(--transition-med), transform var(--transition-med);
    }

    .overlay-visible .overlay-card {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .overlay-title {
      font-size: 20px;
      font-weight: 700;
      margin: 0 0 4px;
      color: #f9fafb;
    }

    .overlay-sub {
      margin: 0 0 10px;
      font-size: 13px;
      color: var(--text-soft);
    }

    .overlay-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
    }

    button {
      font-family: inherit;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.95);
      padding: 6px 12px;
      font-size: 13px;
      color: #e5e7eb;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast);
    }

    .btn:hover {
      background: rgba(15, 23, 42, 1);
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(15, 23, 42, 0.9);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #022c22;
      border-color: transparent;
      font-weight: 600;
      box-shadow: 0 10px 24px rgba(34, 197, 94, 0.9);
    }

    .btn-primary:hover {
      box-shadow: 0 12px 30px rgba(34, 197, 94, 1);
    }

    .btn-ghost-danger {
      border-color: rgba(248, 113, 113, 0.7);
      color: #fecaca;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 3px 8px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      font-size: 11px;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.95);
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.9);
    }

    /* Start Screen */

    #start-overlay {
      z-index: 10;
    }

    #start-overlay .overlay-card {
      text-align: left;
    }

    .start-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .start-logo-dot {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 0 18px rgba(56, 189, 248, 0.9);
    }

    .start-tagline {
      font-size: 12px;
      color: var(--text-soft);
      margin-top: 2px;
    }

    .start-controls {
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-soft);
    }

    .start-controls code {
      background: rgba(15, 23, 42, 0.9);
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      font-size: 11px;
    }

    /* Level Up */

    #levelup-overlay {
      z-index: 20;
    }

    #levelup-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .upgrade-card {
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), rgba(15, 23, 42, 0.96));
      padding: 8px 9px 7px;
      cursor: pointer;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
      min-height: 86px;
    }

    .upgrade-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.9);
      border-color: var(--accent);
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.22), rgba(15, 23, 42, 0.98));
    }

    .upgrade-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .upgrade-badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 4px;
    }

    .upgrade-desc {
      font-size: 12px;
      color: var(--text-soft);
    }

    /* Game Over */

    #gameover-overlay {
      z-index: 30;
    }

    .gameover-stats {
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-soft);
    }

    .gameover-stats-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }

    /* MOBILE CONTROLS */

    #mobile-controls {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    #joystick-container {
      position: absolute;
      left: 18px;
      bottom: 28px;
      width: 120px;
      height: 120px;
      pointer-events: auto;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #joystick-base {
      position: relative;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at center, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.8));
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.9);
    }

    #joystick-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at top, #38bdf8, #0f172a);
      border: 1px solid rgba(148, 163, 184, 1);
      box-shadow: 0 10px 25px rgba(56, 189, 248, 0.9);
      touch-action: none;
    }

    #mobile-hint {
      position: absolute;
      left: 18px;
      bottom: 4px;
      font-size: 11px;
      color: var(--text-soft);
      pointer-events: none;
    }

    #mobile-pause-btn {
      position: absolute;
      right: 12px;
      top: 12px;
      pointer-events: auto;
    }

    #mobile-pause-btn button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.95);
      padding: 6px 10px;
      font-size: 12px;
      color: #e5e7eb;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    @media (max-width: 768px) {
      #xp-bar-wrapper {
        width: 92%;
        bottom: 78px; /* joystick ile çakışmasın */
      }

      .hud-pill {
        padding: 3px 8px;
      }
    }

    @media (pointer: coarse) {
      #joystick-container {
        width: 140px;
        height: 140px;
      }
      #joystick-base {
        width: 120px;
        height: 120px;
      }
      #joystick-knob {
        width: 54px;
        height: 54px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        animation: none !important;
        transition: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="game-root">
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
      <!-- HUD -->
      <div id="hud-top">
        <div class="hud-group">
          <div class="hud-pill">
            <span class="hud-label">HP</span>
            <span class="hud-value" id="hud-hp">100 / 100</span>
          </div>
          <div class="hud-pill">
            <span class="hud-label">LEVEL</span>
            <span class="hud-value" id="hud-level">1</span>
          </div>
          <div class="hud-pill">
            <span class="hud-label">KILLS</span>
            <span class="hud-value" id="hud-kills">0</span>
          </div>
        </div>

        <div class="hud-group">
          <div class="hud-pill">
            <span class="hud-label">TIME</span>
            <span class="hud-value" id="hud-time">00:00</span>
          </div>
          <div class="hud-pill">
            <span class="hud-label">BUILD</span>
            <span class="hud-value" id="hud-build">Balanced</span>
          </div>
        </div>
      </div>

      <div id="top-left-hints">
        <div>PC: WASD → hareket, P → durdur/devam</div>
        <div>Mobil: Sol alttaki joystick ile hareket</div>
        <div>Seviye alınca upgrade kartı seç</div>
      </div>

      <div id="xp-bar-wrapper">
        <div id="xp-bar-inner">
          <div id="xp-fill"></div>
          <div id="xp-label">XP 0 / 10</div>
        </div>
      </div>

      <!-- Start -->
      <div id="start-overlay" class="overlay overlay-visible">
        <div class="overlay-card">
          <div class="start-title">
            <div class="start-logo-dot"></div>
            <div>
              <div class="overlay-title">Nova Arena</div>
              <div class="start-tagline">
                Sonsuz dünyanın içinde gezinen mini rogue-survivor.
              </div>
            </div>
          </div>
          <p class="overlay-sub">
            Artık sabit arenada sıkışmadın: Farklı bölgelere yürü, yeni biyomlar ve engeller keşfet.
            Düşmanların davranışları, bölgelere göre değişiyor. Seviye atladıkça build’ini kur,
            hatta çift atışlı silahlar aç.
          </p>
          <div class="start-controls">
            <div><strong>PC:</strong> <code>W A S D</code> → Hareket, <code>P</code> → Duraklat</div>
            <div><strong>Mobil:</strong> Sol alttaki joystick ile hareket</div>
            <div>Nișan + ateș otomatik, en yakın düşmana.</div>
          </div>
          <div class="overlay-actions">
            <button id="btn-start" class="btn btn-primary">▶ Oyunu Başlat</button>
          </div>
        </div>
      </div>

      <!-- Level Up -->
      <div id="levelup-overlay" class="overlay" style="display:none;">
        <div class="overlay-card">
          <div class="overlay-title">Seviye Atladın!</div>
          <p class="overlay-sub">
            Aşağıdaki geliştirmelerden birini seç. Farklı run’larda farklı kombinasyonlarla oyna.
          </p>
          <div id="levelup-cards"></div>
        </div>
      </div>

      <!-- Game Over -->
      <div id="gameover-overlay" class="overlay" style="display:none;">
        <div class="overlay-card">
          <div class="overlay-title">Oyun Bitti</div>
          <p class="overlay-sub" id="gameover-text">
            Güzel deneme! Farklı bölgelere girip yeni build’lerle tekrar dene.
          </p>
          <div class="gameover-stats">
            <div class="gameover-stats-row">
              <span>Toplam süre:</span>
              <span id="stat-time">00:00</span>
            </div>
            <div class="gameover-stats-row">
              <span>Öldürülen düşman:</span>
              <span id="stat-kills">0</span>
            </div>
            <div class="gameover-stats-row">
              <span>En yüksek seviye:</span>
              <span id="stat-level">1</span>
            </div>
          </div>
          <div class="overlay-actions">
            <button id="btn-restart" class="btn btn-primary">↻ Tekrar Oyna</button>
            <button id="btn-quit" class="btn btn-ghost-danger">⏻ Kapat / Dinlen</button>
          </div>
        </div>
      </div>

      <!-- MOBILE CONTROLS -->
      <div id="mobile-controls">
        <div id="mobile-pause-btn">
          <button id="btn-mobile-pause">⏸ / ▶</button>
        </div>
        <div id="joystick-container">
          <div id="joystick-base">
            <div id="joystick-knob"></div>
          </div>
        </div>
        <div id="mobile-hint">Mobil: sol alttaki joystick ile hareket</div>
      </div>
    </div>
  </div>

  <script>
    // ========= KANVAS & TEMEL AYAR =========
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function getScreenRect() {
      return canvas.getBoundingClientRect();
    }

    // Dünya boyutu (büyük ama sonlu bir alan)
    const WORLD = { width: 3600, height: 3600 };
    const WORLD_HALF_W = WORLD.width / 2;
    const WORLD_HALF_H = WORLD.height / 2;

    const camera = { x: 0, y: 0 };

    function worldToScreen(wx, wy) {
      const rect = getScreenRect();
      const sx = wx - camera.x + rect.width / 2;
      const sy = wy - camera.y + rect.height / 2;
      return { x: sx, y: sy };
    }

    // ========= OYUN DURUMU =========
    const GAME_STATE = {
      START: "start",
      PLAYING: "playing",
      LEVELUP: "levelup",
      GAMEOVER: "gameover",
      PAUSED: "paused"
    };

    let gameState = GAME_STATE.START;

    const keys = { w: false, a: false, s: false, d: false };

    window.addEventListener("keydown", (e) => {
      if (e.key === "w" || e.key === "W") keys.w = true;
      if (e.key === "a" || e.key === "A") keys.a = true;
      if (e.key === "s" || e.key === "S") keys.s = true;
      if (e.key === "d" || e.key === "D") keys.d = true;

      if (e.key === "p" || e.key === "P") {
        togglePause();
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "w" || e.key === "W") keys.w = false;
      if (e.key === "a" || e.key === "A") keys.a = false;
      if (e.key === "s" || e.key === "S") keys.s = false;
      if (e.key === "d" || e.key === "D") keys.d = false;
    });

    // ========= MOBİL JOYSTICK =========
    const joystickBase = document.getElementById("joystick-base");
    const joystickKnob = document.getElementById("joystick-knob");
    const mobilePauseBtn = document.getElementById("btn-mobile-pause");

    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    let joystickVector = { x: 0, y: 0 }; // -1..1

    function getRelativePos(event, element) {
      const rect = element.getBoundingClientRect();
      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    function startJoystick(event) {
      event.preventDefault();
      joystickActive = true;
      const rect = joystickBase.getBoundingClientRect();
      joystickCenter.x = rect.width / 2;
      joystickCenter.y = rect.height / 2;
      updateJoystick(event);
    }

    function moveJoystick(event) {
      if (!joystickActive) return;
      event.preventDefault();
      updateJoystick(event);
    }

    function endJoystick(event) {
      event && event.preventDefault();
      joystickActive = false;
      joystickVector.x = 0;
      joystickVector.y = 0;
      joystickKnob.style.transform = "translate(-50%, -50%)";
    }

    function updateJoystick(event) {
      const pos = getRelativePos(event, joystickBase);
      const dx = pos.x - joystickCenter.x;
      const dy = pos.y - joystickCenter.y;
      const maxDist = joystickBase.clientWidth / 2 - 10;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let nx = dx;
      let ny = dy;
      if (dist > maxDist) {
        const ratio = maxDist / dist;
        nx *= ratio;
        ny *= ratio;
      }
      joystickKnob.style.transform =
        `translate(${nx}px, ${ny}px) translate(-50%, -50%)`;

      const normX = nx / maxDist;
      const normY = ny / maxDist;
      joystickVector.x = normX;
      joystickVector.y = normY;
    }

    joystickBase.addEventListener("pointerdown", startJoystick);
    window.addEventListener("pointermove", moveJoystick);
    window.addEventListener("pointerup", endJoystick);
    window.addEventListener("pointercancel", endJoystick);

    mobilePauseBtn.addEventListener("click", () => {
      togglePause();
    });

    function togglePause() {
      if (gameState === GAME_STATE.PLAYING) {
        gameState = GAME_STATE.PAUSED;
      } else if (gameState === GAME_STATE.PAUSED) {
        gameState = GAME_STATE.PLAYING;
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
      }
    }

    // ========= ENTİTİLER =========
    const player = {
      x: 0,
      y: 0,
      radius: 16,
      speed: 220,
      maxHp: 100,
      hp: 100,
      regen: 0,
      damage: 25,
      fireRate: 2.4, // saniye başına mermi
      bulletSpeed: 420,
      bulletSize: 5,
      bulletPierce: 0,
      pickupRadius: 70,
      weaponMode: "single" // "single" | "twin"
    };

    const bullets = [];
    const enemies = [];
    const xpOrbs = [];
    const obstacles = [];

    let enemySpawnTimer = 0;
    let enemySpawnInterval = 1.4;
    let timeElapsed = 0;
    let killCount = 0;

    let bulletCooldown = 0;

    let level = 1;
    let xp = 0;
    let xpNeeded = 10;

    const hudHp = document.getElementById("hud-hp");
    const hudLevel = document.getElementById("hud-level");
    const hudKills = document.getElementById("hud-kills");
    const hudTime = document.getElementById("hud-time");
    const hudBuild = document.getElementById("hud-build");
    const xpFill = document.getElementById("xp-fill");
    const xpLabel = document.getElementById("xp-label");

    const startOverlay = document.getElementById("start-overlay");
    const levelupOverlay = document.getElementById("levelup-overlay");
    const gameoverOverlay = document.getElementById("gameover-overlay");
    const levelupCardsContainer = document.getElementById("levelup-cards");

    const statTime = document.getElementById("stat-time");
    const statKills = document.getElementById("stat-kills");
    const statLevel = document.getElementById("stat-level");

    const btnStart = document.getElementById("btn-start");
    const btnRestart = document.getElementById("btn-restart");
    const btnQuit = document.getElementById("btn-quit");

    btnStart.addEventListener("click", () => {
      startOverlay.classList.remove("overlay-visible");
      startOverlay.style.display = "none";
      startNewGame();
    });

    btnRestart.addEventListener("click", () => {
      gameoverOverlay.classList.remove("overlay-visible");
      gameoverOverlay.style.display = "none";
      startNewGame();
    });

    btnQuit.addEventListener("click", () => {
      gameState = GAME_STATE.START;
      gameoverOverlay.classList.remove("overlay-visible");
      gameoverOverlay.style.display = "none";
      startOverlay.style.display = "flex";
      requestAnimationFrame(() => {
        startOverlay.classList.add("overlay-visible");
      });
    });

    // ========= BİYOM SİSTEMİ =========
    function getBiome(x, y) {
      const ax = Math.abs(x);
      const ay = Math.abs(y);
      if (ax < 600 && ay < 600) return "plaza";      // orta bölge
      if (y < -800) return "frost";                 // yukarı: buz
      if (y > 800) return "lava";                   // aşağı: lav
      if (x > 800) return "desert";                 // sağ: çöl
      if (x < -800) return "forest";                // sol: orman
      return "field";
    }

    // ========= UPGRADE SİSTEMİ =========
    const UPGRADE_POOL = [
      {
        id: "dmg1",
        title: "Hasar I",
        desc: "+%20 mermi hasarı.",
        apply: () => { player.damage *= 1.2; },
        tags: ["Saldırı", "Hasar"]
      },
      {
        id: "dmg2",
        title: "Hasar II",
        desc: "+%30 mermi hasarı.",
        apply: () => { player.damage *= 1.3; },
        tags: ["Saldırı", "Hasar"]
      },
      {
        id: "firerate1",
        title: "Ateş Hızı I",
        desc: "+%20 atış hızı (daha sık mermi).",
        apply: () => { player.fireRate *= 1.2; },
        tags: ["Saldırı", "Hız"]
      },
      {
        id: "firerate2",
        title: "Ateş Hızı II",
        desc: "+%30 atış hızı.",
        apply: () => { player.fireRate *= 1.3; },
        tags: ["Saldırı", "Hız"]
      },
      {
        id: "movespeed1",
        title: "Hareket I",
        desc: "+%20 hareket hızı.",
        apply: () => { player.speed *= 1.2; },
        tags: ["Savunma", "Hareket"]
      },
      {
        id: "hp1",
        title: "Dayanıklılık I",
        desc: "Maksimum HP +20, mevcut HP yenilenir.",
        apply: () => { player.maxHp += 20; player.hp = Math.min(player.hp + 20, player.maxHp); },
        tags: ["Savunma", "HP"]
      },
      {
        id: "regen1",
        title: "Rejen I",
        desc: "Her saniye +1 pasif can yenilenmesi.",
        apply: () => { player.regen += 1; },
        tags: ["Savunma", "Rejen"]
      },
      {
        id: "pickup1",
        title: "Manyetik Alan",
        desc: "XP çekim alanı +%60.",
        apply: () => { player.pickupRadius *= 1.6; },
        tags: ["Kalite", "XP"]
      },
      {
        id: "bulletSpeed",
        title: "Mermi Hızı",
        desc: "Mermi hızı +%40, daha uzağa daha hızlı.",
        apply: () => { player.bulletSpeed *= 1.4; },
        tags: ["Saldırı", "Kontrol"]
      },
      {
        id: "pierce",
        title: "Delici Mermi",
        desc: "Mermiler +1 düşman daha delip geçebilir.",
        apply: () => { player.bulletPierce += 1; },
        tags: ["Saldırı", "AOE"]
      },
      {
        id: "twinShot",
        title: "Çift Atış",
        desc: "Her atışta 2 mermi hafif açıyla çıkar. Hasar biraz düşer.",
        apply: () => {
          player.weaponMode = "twin";
          player.damage *= 0.9;
        },
        tags: ["Saldırı", "Silah"]
      }
    ];

    function getRandomUpgrades(count) {
      const pool = [...UPGRADE_POOL];
      const result = [];
      while (result.length < count && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        result.push(pool.splice(idx, 1)[0]);
      }
      return result;
    }

    function showLevelup() {
      if (gameState !== GAME_STATE.PLAYING) return;
      gameState = GAME_STATE.LEVELUP;
      levelupCardsContainer.innerHTML = "";

      const choices = getRandomUpgrades(3);
      choices.forEach(up => {
        const card = document.createElement("div");
        card.className = "upgrade-card";
        card.innerHTML = `
          <div class="upgrade-title">${up.title}</div>
          <div class="upgrade-badge-row">
            ${up.tags
              .map(t => `<span class="badge"><span class="badge-dot"></span>${t}</span>`)
              .join("")}
          </div>
          <div class="upgrade-desc">${up.desc}</div>
        `;
        card.addEventListener("click", () => {
          up.apply();
          levelupOverlay.classList.remove("overlay-visible");
          levelupOverlay.style.display = "none";
          gameState = GAME_STATE.PLAYING;
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
        });
        levelupCardsContainer.appendChild(card);
      });

      levelupOverlay.style.display = "flex";
      requestAnimationFrame(() => {
        levelupOverlay.classList.add("overlay-visible");
      });
    }

    // ========= YARDIMCI FONKSİYONLAR =========
    function clamp(v, min, max) {
      return v < min ? min : v > max ? max : v;
    }

    function length(x, y) {
      return Math.sqrt(x * x + y * y);
    }

    function normalize(x, y) {
      const len = Math.sqrt(x * x + y * y) || 1;
      return { x: x / len, y: y / len };
    }

    function rotateVec(x, y, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      return { x: x * c - y * s, y: x * s + y * c };
    }

    function formatTime(t) {
      const total = Math.floor(t);
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
    }

    // Basit çarpışma çözümü: dairesel engeller
    function resolveCircleObstacleCollision(obj, radius) {
      for (const o of obstacles) {
        const dx = obj.x - o.x;
        const dy = obj.y - o.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = radius + o.radius;
        if (dist > 0 && dist < minDist) {
          const overlap = minDist - dist;
          const n = { x: dx / dist, y: dy / dist };
          obj.x += n.x * overlap;
          obj.y += n.y * overlap;
        }
      }
    }

    // ========= OBSTACLE OLUŞTURMA =========
    function generateObstacles() {
      obstacles.length = 0;
      const count = 80;
      for (let i = 0; i < count; i++) {
        const x = (Math.random() - 0.5) * WORLD.width * 0.9;
        const y = (Math.random() - 0.5) * WORLD.height * 0.9;
        const radius = 30 + Math.random() * 40;
        const type = Math.floor(Math.random() * 3); // 0: kaya, 1: sütun, 2: kristal
        obstacles.push({ x, y, radius, type });
      }
    }

    // ========= OYUN BAŞLATMA / SIFIRLAMA =========
    function resetGameState() {
      player.x = 0;
      player.y = 0;
      player.radius = 16;
      player.speed = 220;
      player.maxHp = 100;
      player.hp = 100;
      player.regen = 0;
      player.damage = 25;
      player.fireRate = 2.4;
      player.bulletSpeed = 420;
      player.bulletSize = 5;
      player.bulletPierce = 0;
      player.pickupRadius = 70;
      player.weaponMode = "single";

      bullets.length = 0;
      enemies.length = 0;
      xpOrbs.length = 0;
      enemySpawnTimer = 0;
      enemySpawnInterval = 1.4;
      timeElapsed = 0;
      killCount = 0;
      bulletCooldown = 0;
      level = 1;
      xp = 0;
      xpNeeded = 10;
      hudBuild.textContent = "Balanced";

      joystickVector.x = 0;
      joystickVector.y = 0;
      joystickKnob.style.transform = "translate(-50%, -50%)";

      camera.x = player.x;
      camera.y = player.y;

      generateObstacles();
    }

    function startNewGame() {
      resetGameState();
      gameState = GAME_STATE.PLAYING;
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function onGameOver() {
      gameState = GAME_STATE.GAMEOVER;
      statTime.textContent = formatTime(timeElapsed);
      statKills.textContent = killCount.toString();
      statLevel.textContent = level.toString();

      gameoverOverlay.style.display = "flex";
      requestAnimationFrame(() => {
        gameoverOverlay.classList.add("overlay-visible");
      });
    }

    // ========= ENEMY SPAWN =========
    function spawnEnemy() {
      // Oyuncunun etrafında bir halka üzerinde spawn
      const angle = Math.random() * Math.PI * 2;
      const minDist = 400;
      const maxDist = 800;
      const dist = minDist + Math.random() * (maxDist - minDist);

      let x = player.x + Math.cos(angle) * dist;
      let y = player.y + Math.sin(angle) * dist;

      x = clamp(x, -WORLD_HALF_W + 40, WORLD_HALF_W - 40);
      y = clamp(y, -WORLD_HALF_H + 40, WORLD_HALF_H - 40);

      const biome = getBiome(x, y);
      const difficultyTime = timeElapsed;

      // scaling daha makul: hız ve HP yavaş artıyor
      const baseSpeed = 70 + Math.random() * 40;
      const baseHp = 30 + Math.random() * 20;
      const speedScale = 1 + difficultyTime / 180;
      const hpScale = 1 + difficultyTime / 120;

      // biyoma göre tip & biraz bonus
      let type; // davranış + şekil
      switch (biome) {
        case "plaza":
          type = Math.random() < 0.5 ? 0 : 1;
          break;
        case "forest":
          type = Math.random() < 0.5 ? 0 : 3;
          break;
        case "desert":
          type = 1; // charger
          break;
        case "frost":
          type = Math.random() < 0.7 ? 2 : 0; // orbit
          break;
        case "lava":
          type = Math.random() < 0.7 ? 3 : 1; // zigzag / hızlı
          break;
        default:
          type = Math.floor(Math.random() * 4);
      }

      enemies.push({
        x,
        y,
        radius: 16,
        speed: baseSpeed * speedScale,
        baseSpeed: baseSpeed,
        hp: baseHp * hpScale,
        maxHp: baseHp * hpScale,
        damage: 7 * (1 + difficultyTime / 150),
        knockback: 220,
        type,                    // 0: normal, 1: charger, 2: orbit, 3: zigzag
        phase: Math.random() * Math.PI * 2
      });
    }

    // ========= GÜNCELLEME =========
    function updatePlayer(dt) {
      let dx = 0;
      let dy = 0;

      // Keyboard
      if (keys.w) dy -= 1;
      if (keys.s) dy += 1;
      if (keys.a) dx -= 1;
      if (keys.d) dx += 1;

      // Joystick
      dx += joystickVector.x;
      dy += joystickVector.y;

      if (dx !== 0 || dy !== 0) {
        const n = normalize(dx, dy);
        player.x += n.x * player.speed * dt;
        player.y += n.y * player.speed * dt;
      }

      // Dünya sınırları
      player.x = clamp(player.x, -WORLD_HALF_W + 40, WORLD_HALF_W - 40);
      player.y = clamp(player.y, -WORLD_HALF_H + 40, WORLD_HALF_H - 40);

      // Engeller
      resolveCircleObstacleCollision(player, player.radius);

      // Rejen
      if (player.regen > 0) {
        player.hp = clamp(player.hp + player.regen * dt, 0, player.maxHp);
      }
    }

    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        let dir = { x: dx / dist, y: dy / dist };

        let vx = dir.x;
        let vy = dir.y;

        // Davranışlara göre hareket
        switch (e.type) {
          case 1: { // charger
            const boost = dist < 260 ? 2.2 : 1.0;
            vx *= boost;
            vy *= boost;
            break;
          }
          case 2: { // orbit
            const perp = { x: -dir.y, y: dir.x };
            vx = dir.x * 0.6 + perp.x * 0.8;
            vy = dir.y * 0.6 + perp.y * 0.8;
            const n = normalize(vx, vy);
            vx = n.x;
            vy = n.y;
            break;
          }
          case 3: { // zigzag
            const perp2 = { x: -dir.y, y: dir.x };
            const wave = Math.sin((timeElapsed + e.phase) * 3);
            vx = dir.x + perp2.x * 0.7 * wave;
            vy = dir.y + perp2.y * 0.7 * wave;
            const n2 = normalize(vx, vy);
            vx = n2.x;
            vy = n2.y;
            break;
          }
          default: // normal
            break;
        }

        e.x += vx * e.speed * dt;
        e.y += vy * e.speed * dt;

        // Dünya sınırları
        e.x = clamp(e.x, -WORLD_HALF_W + 30, WORLD_HALF_W - 30);
        e.y = clamp(e.y, -WORLD_HALF_H + 30, WORLD_HALF_H - 30);

        // Engeller
        resolveCircleObstacleCollision(e, e.radius);

        // Player çarpışma
        const distToPlayer = Math.sqrt(
          (player.x - e.x) * (player.x - e.x) +
          (player.y - e.y) * (player.y - e.y)
        );
        if (distToPlayer < player.radius + e.radius) {
          player.hp -= e.damage * dt;
          const push = normalize(player.x - e.x, player.y - e.y);
          player.x += push.x * e.knockback * dt * 0.25;
          player.y += push.y * e.knockback * dt * 0.25;

          if (player.hp <= 0) {
            player.hp = 0;
            onGameOver();
            return;
          }
        }

        if (e.hp <= 0) {
          xpOrbs.push({
            x: e.x,
            y: e.y,
            radius: 6,
            value: 1 + Math.random() * 1
          });
          enemies.splice(i, 1);
          killCount++;
        }
      }
    }

    function updateBullets(dt) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (
          b.x < -WORLD_HALF_W - 60 || b.x > WORLD_HALF_W + 60 ||
          b.y < -WORLD_HALF_H - 60 || b.y > WORLD_HALF_H + 60 ||
          b.life <= 0
        ) {
          bullets.splice(i, 1);
          continue;
        }

        b.life -= dt;

        // Düşman çarpışma
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          const dist = length(e.x - b.x, e.y - b.y);
          if (dist < e.radius + b.radius) {
            e.hp -= player.damage;
            b.pierced++;

            if (b.pierced > player.bulletPierce) {
              bullets.splice(i, 1);
            }

            if (e.hp <= 0) {
              xpOrbs.push({
                x: e.x,
                y: e.y,
                radius: 6,
                value: 1 + Math.random() * 1
              });
              enemies.splice(j, 1);
              killCount++;
            }
            break;
          }
        }
      }
    }

    function updateXpOrbs(dt) {
      for (let i = xpOrbs.length - 1; i >= 0; i--) {
        const orb = xpOrbs[i];
        const dist = length(player.x - orb.x, player.y - orb.y);
        if (dist < player.pickupRadius) {
          const dir = normalize(player.x - orb.x, player.y - orb.y);
          const strength = 250 * (1 - dist / player.pickupRadius);
          orb.x += dir.x * strength * dt;
          orb.y += dir.y * strength * dt;
        }

        if (dist < player.radius + orb.radius + 2) {
          xp += orb.value;
          xpOrbs.splice(i, 1);

          if (xp >= xpNeeded) {
            level++;
            xp -= xpNeeded;
            xpNeeded = Math.floor(10 + level * level * 1.3);
            enemySpawnInterval = Math.max(0.5, enemySpawnInterval - 0.04);
            showLevelup();
          }
        }
      }
    }

    function fireBulletsTowards(dir) {
      // Tek veya çift atış
      if (player.weaponMode === "twin") {
        const spread = 0.18;
        const dir1 = rotateVec(dir.x, dir.y, -spread);
        const dir2 = rotateVec(dir.x, dir.y, spread);

        const b1 = {
          x: player.x,
          y: player.y,
          radius: player.bulletSize,
          vx: dir1.x * player.bulletSpeed,
          vy: dir1.y * player.bulletSpeed,
          life: 1.2,
          pierced: 0
        };
        const b2 = {
          x: player.x,
          y: player.y,
          radius: player.bulletSize,
          vx: dir2.x * player.bulletSpeed,
          vy: dir2.y * player.bulletSpeed,
          life: 1.2,
          pierced: 0
        };
        bullets.push(b1, b2);
      } else {
        const bullet = {
          x: player.x,
          y: player.y,
          radius: player.bulletSize,
          vx: dir.x * player.bulletSpeed,
          vy: dir.y * player.bulletSpeed,
          life: 1.2,
          pierced: 0
        };
        bullets.push(bullet);
      }
    }

    function autoShoot(dt) {
      bulletCooldown -= dt;
      if (bulletCooldown > 0) return;
      if (enemies.length === 0) return;

      let nearest = null;
      let bestDist = Infinity;
      for (const e of enemies) {
        const d = length(e.x - player.x, e.y - player.y);
        if (d < bestDist) {
          bestDist = d;
          nearest = e;
        }
      }

      if (!nearest) return;
      const dir = normalize(nearest.x - player.x, nearest.y - player.y);

      fireBulletsTowards(dir);

      bulletCooldown = 1 / player.fireRate;
    }

    function updateHud() {
      hudHp.textContent = `${Math.round(player.hp)} / ${player.maxHp}`;
      hudLevel.textContent = level.toString();
      hudKills.textContent = killCount.toString();
      hudTime.textContent = formatTime(timeElapsed);
      xpFill.style.width = `${clamp((xp / xpNeeded) * 100, 0, 100)}%`;
      xpLabel.textContent = `XP ${Math.floor(x)} / ${xpNeeded}`;
    }

    // ========= ÇİZİM =========
    function drawBackground() {
      const rect = getScreenRect();
      ctx.save();
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, rect.width, rect.height);

      // Biyom rengi
      const biome = getBiome(player.x, player.y);
      let tint;
      switch (biome) {
        case "plaza":
          tint = "rgba(56,189,248,0.18)";
          break;
        case "forest":
          tint = "rgba(34,197,94,0.18)";
          break;
        case "desert":
          tint = "rgba(250,204,21,0.16)";
          break;
        case "frost":
          tint = "rgba(59,130,246,0.18)";
          break;
        case "lava":
          tint = "rgba(248,113,113,0.2)";
          break;
        default:
          tint = "rgba(148,163,184,0.12)";
      }

      // Grid çizimi (kamera bazlı)
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = "#0f172a";
      const grid = 180;
      const startX = Math.floor((camera.x - rect.width / 2) / grid) * grid;
      const endX = Math.floor((camera.x + rect.width / 2) / grid) * grid;
      const startY = Math.floor((camera.y - rect.height / 2) / grid) * grid;
      const endY = Math.floor((camera.y + rect.height / 2) / grid) * grid;

      for (let gx = startX; gx <= endX; gx += grid) {
        const sx = gx - camera.x + rect.width / 2;
        ctx.beginPath();
        ctx.moveTo(sx, 0);
        ctx.lineTo(sx, rect.height);
        ctx.stroke();
      }
      for (let gy = startY; gy <= endY; gy += grid) {
        const sy = gy - camera.y + rect.height / 2;
        ctx.beginPath();
        ctx.moveTo(0, sy);
        ctx.lineTo(rect.width, sy);
        ctx.stroke();
      }

      ctx.globalAlpha = 1;

      // Biyom tint
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      const grad = ctx.createRadialGradient(
        centerX,
        centerY,
        0,
        centerX,
        centerY,
        Math.max(rect.width, rect.height)
      );
      grad.addColorStop(0, tint);
      grad.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, rect.width, rect.height);

      ctx.restore();
    }

    function drawObstacles() {
      ctx.save();
      for (const o of obstacles) {
        const s = worldToScreen(o.x, o.y);

        // gölge
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.ellipse(s.x + 4, s.y + o.radius * 0.7, o.radius, o.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        let grad;
        switch (o.type) {
          case 0: // kaya
            grad = ctx.createRadialGradient(
              s.x - 6, s.y - 6, 4,
              s.x, s.y, o.radius + 6
            );
            grad.addColorStop(0, "#e5e7eb");
            grad.addColorStop(0.4, "#6b7280");
            grad.addColorStop(1, "#020617");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(s.x, s.y, o.radius, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 1: // sütun
            grad = ctx.createLinearGradient(s.x - o.radius, s.y - o.radius, s.x + o.radius, s.y + o.radius);
            grad.addColorStop(0, "#f9fafb");
            grad.addColorStop(0.4, "#9ca3af");
            grad.addColorStop(1, "#020617");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(s.x - o.radius * 0.8, s.y - o.radius);
            ctx.lineTo(s.x + o.radius * 0.8, s.y - o.radius);
            ctx.lineTo(s.x + o.radius * 0.5, s.y + o.radius);
            ctx.lineTo(s.x - o.radius * 0.5, s.y + o.radius);
            ctx.closePath();
            ctx.fill();
            break;
          case 2: // kristal
          default:
            grad = ctx.createLinearGradient(s.x, s.y - o.radius, s.x, s.y + o.radius);
            grad.addColorStop(0, "#a5b4fc");
            grad.addColorStop(0.5, "#6366f1");
            grad.addColorStop(1, "#020617");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(s.x, s.y - o.radius);
            ctx.lineTo(s.x + o.radius * 0.6, s.y);
            ctx.lineTo(s.x, s.y + o.radius);
            ctx.lineTo(s.x - o.radius * 0.6, s.y);
            ctx.closePath();
            ctx.fill();
            break;
        }
      }
      ctx.restore();
    }

    function drawPlayer() {
      const s = worldToScreen(player.x, player.y);
      ctx.save();
      ctx.translate(s.x, s.y);

      // dış halo
      const haloGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius * 2.4);
      haloGrad.addColorStop(0, "rgba(56,189,248,0.4)");
      haloGrad.addColorStop(1, "rgba(56,189,248,0)");
      ctx.fillStyle = haloGrad;
      ctx.beginPath();
      ctx.arc(0, 0, player.radius * 2.4, 0, Math.PI * 2);
      ctx.fill();

      // hedefe göre yön
      let angle = 0;
      if (enemies.length > 0) {
        let nearest = enemies[0];
        let bestDist = length(nearest.x - player.x, nearest.y - player.y);
        for (const e of enemies) {
          const d = length(e.x - player.x, e.y - player.y);
          if (d < bestDist) {
            bestDist = d;
            nearest = e;
          }
        }
        angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
      }
      ctx.rotate(angle);

      const w = player.radius * 1.6;
      const h = player.radius * 2.3;

      const grad = ctx.createLinearGradient(-w / 2, -h / 2, w / 2, h / 2);
      grad.addColorStop(0, "#f9fafb");
      grad.addColorStop(0.3, "#38bdf8");
      grad.addColorStop(0.8, "#0f172a");
      ctx.fillStyle = grad;

      // Elmas/kapsül şekli
      ctx.beginPath();
      ctx.moveTo(0, -h / 2);
      ctx.lineTo(w / 2, 0);
      ctx.lineTo(0, h / 2);
      ctx.lineTo(-w / 2, 0);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(15,23,42,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -h / 2 + 4);
      ctx.lineTo(0, h / 2 - 4);
      ctx.stroke();

      ctx.restore();
    }

    function drawEnemies() {
      ctx.save();
      for (const e of enemies) {
        const s = worldToScreen(e.x, e.y);

        // gölge
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.ellipse(s.x + 4, s.y + e.radius, e.radius * 0.9, e.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.save();
        ctx.translate(s.x, s.y);

        const r = e.radius;
        let fillGrad;

        switch (e.type) {
          case 0: // daire - turuncu normal
            fillGrad = ctx.createRadialGradient(-4, -4, 4, 0, 0, r + 4);
            fillGrad.addColorStop(0, "#fee2e2");
            fillGrad.addColorStop(0.4, "#f97316");
            fillGrad.addColorStop(1, "#111827");
            ctx.fillStyle = fillGrad;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 1: // kare - charger
            fillGrad = ctx.createLinearGradient(-r, -r, r, r);
            fillGrad.addColorStop(0, "#fee2e2");
            fillGrad.addColorStop(0.4, "#f97316");
            fillGrad.addColorStop(1, "#111827");
            ctx.fillStyle = fillGrad;
            const s2 = r * 1.2;
            ctx.beginPath();
            ctx.moveTo(-s2, -s2);
            ctx.lineTo(s2, -s2);
            ctx.lineTo(s2, s2);
            ctx.lineTo(-s2, s2);
            ctx.closePath();
            ctx.fill();
            break;
          case 2: // üçgen - orbit
            fillGrad = ctx.createLinearGradient(-r, -r, r, r);
            fillGrad.addColorStop(0, "#e0f2fe");
            fillGrad.addColorStop(0.4, "#3b82f6");
            fillGrad.addColorStop(1, "#020617");
            ctx.fillStyle = fillGrad;
            ctx.beginPath();
            ctx.moveTo(0, -r * 1.4);
            ctx.lineTo(r * 1.2, r * 0.9);
            ctx.lineTo(-r * 1.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
            break;
          case 3: // altıgen - zigzag
          default:
            fillGrad = ctx.createLinearGradient(-r, 0, r, 0);
            fillGrad.addColorStop(0, "#bbf7d0");
            fillGrad.addColorStop(0.4, "#22c55e");
            fillGrad.addColorStop(1, "#020617");
            ctx.fillStyle = fillGrad;
            ctx.beginPath();
            const sides = 6;
            for (let k = 0; k < sides; k++) {
              const ang = (Math.PI * 2 * k) / sides;
              const px = Math.cos(ang) * r * 1.1;
              const py = Math.sin(ang) * r * 1.1;
              if (k === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            break;
        }

        ctx.restore();

        // HP bar
        const ratio = clamp(e.hp / e.maxHp, 0, 1);
        const barW = e.radius * 1.6;
        const barH = 4;
        ctx.fillStyle = "rgba(15,23,42,0.9)";
        ctx.fillRect(s.x - barW / 2, s.y - e.radius - 8, barW, barH);
        ctx.fillStyle = "#22c55e";
        ctx.fillRect(s.x - barW / 2, s.y - e.radius - 8, barW * ratio, barH);
      }
      ctx.restore();
    }

    function drawBullets() {
      ctx.save();
      for (const b of bullets) {
        const s = worldToScreen(b.x, b.y);
        const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, b.radius * 2.3);
        grad.addColorStop(0, "#fef9c3");
        grad.addColorStop(0.3, "#eab308");
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(s.x, s.y, b.radius * 2.3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(s.x, s.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawXpOrbs() {
      ctx.save();
      for (const orb of xpOrbs) {
        const s = worldToScreen(orb.x, orb.y);
        const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, orb.radius * 2.4);
        grad.addColorStop(0, "#bbf7d0");
        grad.addColorStop(0.4, "#22c55e");
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(s.x, s.y, orb.radius * 2.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#4ade80";
        ctx.beginPath();
        ctx.arc(s.x, s.y, orb.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    // ========= GAME LOOP =========
    let lastTime = 0;

    function gameLoop(timestamp) {
      if (gameState !== GAME_STATE.PLAYING) return;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      timeElapsed += dt;

      enemySpawnTimer -= dt;
      if (enemySpawnTimer <= 0) {
        spawnEnemy();
        enemySpawnTimer = enemySpawnInterval;
      }

      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      updateXpOrbs(dt);
      autoShoot(dt);
      updateHud();

      // Kamera oyuncuyu takip etsin
      camera.x = player.x;
      camera.y = player.y;

      drawBackground();
      drawObstacles();
      drawXpOrbs();
      drawEnemies();
      drawBullets();
      drawPlayer();

      if (gameState === GAME_STATE.PLAYING) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Başlangıçta sadece start ekranı görünüyor; oyun startNewGame ile başlıyor.
  </script>
</body>
</html>
